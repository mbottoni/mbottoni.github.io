
<!DOCTYPE html>
<html lang='en-US'>
<head>
  <meta charset='utf-8'>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Conditional Tabular GAN - CTGAN</title>
  <meta name="description" content="One of the most interesting ideas on the last decades in machine learning is the GAN architecture for generatine model. While GANs have 
shown remarkable success in generating high-quality images and other continuous data types, tabular data poses unique challenges. Tabular data often contains a 
mix of discrete and continuous variables, with complex dependencies between them. Traditional GAN architectures struggle to capture these intricacies, leading 
to poor performance when applied directly to tabular data. CTGAN addresses these challenges by introducing a specialized framework for generating 
realistic synthetic tabular data.">
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="icon" href="/favicon.svg" type="image/svg+xml">
  <link rel="canonical" href="https://mbottoni.github.io/2024/08/13/ctgan.html">
  <link rel="alternate" type="application/rss+xml" title="mbottoni" href="https://mbottoni.github.io/feed.xml">
  <style>
  @font-face {
    font-family: 'Open Sans'; src: url('/css/OpenSans-300-Normal.woff2') format('woff2');
    font-weight: 300; font-style: normal;
  }
  @font-face {
    font-family: 'JetBrains Mono'; src: url('/css/JetBrainsMono-400-Normal.woff2') format('woff2');
    font-weight: 400; font-style: normal;
  }
  @font-face {
    font-family: 'JetBrains Mono'; src: url('/css/JetBrainsMono-700-Normal.woff2') format('woff2');
    font-weight: 700; font-style: normal;
  }
  @font-face {
    font-family: 'EB Garamond'; src: url('/css/EBGaramond-400-Normal.woff2') format('woff2');
    font-weight: 400; font-style: normal;
  }
  @font-face {
    font-family: 'EB Garamond'; src: url('/css/EBGaramond-400-Italic.woff2') format('woff2');
    font-weight: 400; font-style: italic;
  }
  @font-face {
    font-family: 'EB Garamond'; src: url('/css/EBGaramond-700-Normal.woff2') format('woff2');
    font-weight: 700; font-style: normal;
  }
  @font-face {
    font-family: 'EB Garamond'; src: url('/css/EBGaramond-700-Italic.woff2') format('woff2');
    font-weight: 700; font-style: italic;
  }

  * { box-sizing: border-box; margin: 0; padding: 0; margin-block-start: 0; margin-block-end: 0; }

  body {
    max-width: 80ch;
    padding: 2ch;
    margin-left: auto;
    margin-right: auto;
  }

  header { margin-bottom: 2rem; }
  header > nav { display: flex; column-gap: 2ch; align-items: baseline; flex-wrap: wrap; }
  header a { font-style: normal; color: rgba(0, 0, 0, .8); text-decoration: none; }
  header a:hover { color: rgba(0, 0, 0, .8); text-decoration: underline; }
  header .title { font-size: 1.25em; flex-grow: 2; }

  footer { margin-top: 2rem; }
  footer > p { display: flex; column-gap: 2ch; justify-content: center; flex-wrap: wrap; }
  footer a { color: rgba(0, 0, 0, .8); text-decoration: none; white-space: nowrap; }
  footer i { vertical-align: middle; color: rgba(0, 0, 0, .8) }

  .theme-grid { display: grid; gap: 2rem; grid-template-columns: repeat(auto-fit, minmax(16rem, 1fr)); }
  .theme-card { border: 1px solid rgba(0,0,0,.12); border-radius: 1rem; padding: 1.5rem; display: flex; flex-direction: column; gap: .75rem; }
  .theme-card h2 { font-size: 1.35em; }
  .theme-card h2 a { text-decoration: none; color: #b32f1c; }
  .theme-card h2 a:hover { text-decoration: underline; }
  .theme-card p { color: rgba(0,0,0,.75); line-height: 1.5; }
  .theme-meta { font-size: .85em; color: rgba(0,0,0,.6); }

  .theme-page header h1 { font-size: 2em; margin-bottom: .5rem; }
  .theme-page header p { color: rgba(0,0,0,.65); line-height: 1.5; }
  .theme-page { display: flex; flex-direction: column; gap: 1.5rem; }

  .post-list { list-style: none; display: flex; flex-direction: column; gap: 1.5rem; padding: 0; }
  .post-card { display: grid; gap: 1rem; grid-template-columns: minmax(0, 1fr); }
  .post-card__media { display: none; }
  .post-card__body h3 { font-size: 1.1em; margin-bottom: .35rem; }
  .post-card__body p { color: rgba(0, 0, 0, .7); }
  .post-card__media a { display: block; border-radius: .75rem; overflow: hidden; }
  .post-card__media img { width: 100%; height: 100%; object-fit: cover; display: block; }
  @media (min-width: 720px) {
    .post-card { grid-template-columns: 260px 1fr; align-items: center; }
    .post-card__media { display: block; min-height: 160px; }
    .post-card__media:empty { display: block; }
  }

  .theme-pill, .theme-banner a { display: inline-flex; align-items: center; gap: .4rem; font-size: .8em; text-transform: uppercase; letter-spacing: .08em; border: 1px solid rgba(0, 0, 0, .15); border-radius: 999px; padding: .25rem .9rem; text-decoration: none; color: rgba(0, 0, 0, .7); }
  .theme-pill svg, .theme-banner svg { width: .75em; height: .75em; }
  .theme-banner { margin-bottom: 1rem; }
  .theme-banner span { font-size: .8em; color: rgba(0, 0, 0, .6); margin-right: .5rem; }
  
  .katex { font-size: 0.95em !important; color: rgba(0, 0, 0, 0.9); }
  .katex-display { margin: 0.5em 0; overflow-x: auto; overflow-y: hidden; }

  </style>

  <link rel="stylesheet" href="/css/main.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
</head>

<body>
  <header>
    <nav>
      <a class="title" href="/">mbottoni</a>
      <a href="/about.html">About</a>
      <a href="/resume.html">Resume</a>
      <a href="/repositories.html">Repositories</a>
      <a href="/links.html">Links</a>
    </nav>
  </header>

  <main>
  
      <div class="theme-banner">
        <span>Filed under</span>
        <a class="theme-pill" href="/themes/generative.html">
          Diffusion &amp; Generative Modeling
        </a>
      </div>
      <article >

    <h1>
    <a href="#Conditional-Tabular-GAN-CTGAN"><span>Conditional Tabular GAN - CTGAN</span> <time datetime="2024-08-13">Aug 13, 2024</time></a>
    </h1>

<figure>

<img alt="" src="/assets/generative/gan.png">
</figure>
<p><span>One of the most interesting ideas on the last decades in machine learning is the GAN architecture for generatine model. While GANs have </span>
<span>shown remarkable success in generating high-quality images and other continuous data types, tabular data poses unique challenges. Tabular data often contains a </span>
<span>mix of discrete and continuous variables, with complex dependencies between them. Traditional GAN architectures struggle to capture these intricacies, leading </span>
<span>to poor performance when applied directly to tabular data. CTGAN addresses these challenges by introducing a specialized framework for generating </span>
<span>realistic synthetic tabular data.</span></p>
<section id="CTGAN-Architecture">

    <h2>
    <a href="#CTGAN-Architecture"><span>CTGAN Architecture</span> </a>
    </h2>
<p><span>The CTGAN model is based on the GAN framework, comprising two main components: a generator and a discriminator.</span></p>
<ul>
<li>
<span>Generator: The generator is responsible for producing synthetic data that resembles the real data. It takes as </span>
<span>input a noise vector sampled from a standard normal distribution and a conditioning vector. The conditioning vector </span>
<span>encodes specific values of categorical variables, enabling the generation of samples with particular characteristics. The generator </span>
<span>outputs a vector representing a synthetic data sample, which includes both categorical and continuous features.</span>
</li>
<li>
<span>Discriminator: The discriminator</span>&rsquo;<span>s role is to distinguish between real and synthetic data samples. It is a binary classifier </span>
<span>trained to maximize the likelihood of correctly identifying real data from the generator</span>&rsquo;<span>s output. The discriminator receives </span>
<span>both real and synthetic data as input and outputs a probability score indicating whether the input is real or fake.</span>
</li>
</ul>
</section>
<section id="Key-Innovations-in-CTGAN">

    <h2>
    <a href="#Key-Innovations-in-CTGAN"><span>Key Innovations in CTGAN</span> </a>
    </h2>
<p><span>CTGAN introduces several key innovations that enable it to handle the complexities of tabular data:</span></p>
<ul>
<li>
<p><span>Conditional Vector and Mode-specific Normalization: This allows the generator to conditionally generate data based on specific categories. This is </span>
<span>particularly useful in scenarios where some features are strongly dependent on others. For example, in a dataset with gender and age features, conditioning </span>
<span>on gender can help the generator produce age values that are realistic for that gender. Mode-specific normalization is applied to continuous features </span>
<span>during training, ensuring that each mode (category) is normalized  independently. This prevents the generator from learning spurious correlations </span>
<span>between categorical and continuous features.</span></p>
</li>
<li>
<p><span>Training by Sampling: To address the imbalance in categorical data, CTGAN uses a sampling strategy where the generator focuses </span>
<span>on underrepresented categories during training. This ensures that the generator learns to produce realistic samples across </span>
<span>all categories, not just the majority ones.</span></p>
</li>
<li>
<p><span>Logistic Loss for the Generator: The generator</span>&rsquo;<span>s loss function is modified to include a logistic loss term. This encourages the generator to produce samples that </span>
<span>are close to the decision boundary of the discriminator, promoting diversity in the generated samples. The inclusion of this term helps the generator avoid </span>
<span>mode collapse, a common issue in GANs where the generator produces a limited variety of samples.</span></p>
</li>
<li>
<p><span>Training Process. The training process for CTGAN follows the standard GAN training procedure.</span></p>
</li>
<li>
<p><span>Preprocessing: The data is preprocessed to convert categorical variables into one-hot encoded vectors. Continuous variables </span>
<span>are normalized using mode-specific normalization. The data is then split into real samples and conditional vectors.</span></p>
</li>
</ul>
</section>
</article>
    
  </main>

  <footer class="site-footer">
    <p>
      <a href="https://github.com/mbottoni/mbottoni.github.io/edit/master/content/posts/2024-08-13-ctgan.dj">
        <svg class="icon"><use href="/assets/icons.svg#edit"/></svg>
        Fix typo
      </a>
      <a href="/feed.xml">
        <svg class="icon"><use href="/assets/icons.svg#rss"/></svg>
        Subscribe
      </a>
      <a href="mailto:maruanbakriottoni@gmail.com">
        <svg class="icon"><use href="/assets/icons.svg#email"/></svg>
        Get in touch
      </a>
      <a href="https://github.com/mbottoni">
        <svg class="icon"><use href="/assets/icons.svg#github"/></svg>
        mbottoni
      </a>
    </p>
  </footer>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js"></script>
  <script type="module">
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script>
  <script>
    function unwrapPlainSpans(root) {
      for (const span of root.querySelectorAll("span")) {
        if (!(span instanceof HTMLElement)) continue;
        if (span.attributes.length === 0 && span.childElementCount === 0) {
          span.replaceWith(document.createTextNode(span.textContent || ""));
        }
      }
      root.normalize();
    }

    function addCopyButtons() {
      document.querySelectorAll('figure.code-block').forEach(block => {
        if (block.querySelector('.copy-button')) return;
        const button = document.createElement('button');
        button.className = 'copy-button';
        button.textContent = 'Copy';
        button.addEventListener('click', () => {
          const code = block.querySelector('code')?.innerText || '';
          navigator.clipboard.writeText(code).then(() => {
            button.textContent = 'Copied!';
            setTimeout(() => button.textContent = 'Copy', 2000);
          });
        });
        block.appendChild(button);
      });
    }

    document.addEventListener("DOMContentLoaded", () => {
      unwrapPlainSpans(document.body);
      addCopyButtons();
      let attempts = 0;
      const maxAttempts = 40;
      const renderMath = () => {
        if (typeof renderMathInElement === "function") {
          renderMathInElement(document.body, {
            delimiters: [
              { left: "$$", right: "$$", display: true },
              { left: "$", right: "$", display: false },
              { left: "\(", right: "\)", display: false },
              { left: "\[", right: "\]", display: true },
            ],
            throwOnError: false,
          });
        } else if (attempts < maxAttempts) {
          attempts += 1;
          setTimeout(renderMath, 75);
        }
      };
      renderMath();
    });
  </script>
</body>

</html>
